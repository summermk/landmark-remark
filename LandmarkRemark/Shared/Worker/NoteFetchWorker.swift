//
//  NoteFetchWorker.swift
//  LandmarkRemark
//
//  Created by Mira Kim on 17/05/19.
//  Copyright (c) 2019 mira. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Firebase

protocol NoteFetchWorkerProtocol {
    func readNotes(completion: @escaping ([Note.Dto]?) -> Void)
}

/**
    Note Sync Worker is handling the implementation details of
    saving the notes and syncing it
 */
class NoteFetchWorker: NoteFetchWorkerProtocol
{
    // MARK: Firestore related properties
    lazy var db = {
        return Firestore.firestore()
    }()
    
    let noteCollectionPath = "notes"
    
    /**
        Save the new note in Firestore.
     
     - Parameter: DTO for note model
     
     - Throws: json encoding error or parse to dictionary error
     */
    func addNewNote(_ note: Note.Dto) throws {
        let dict = try note.asDictionary()
        
        // add a new document with a generated ID
        var ref: DocumentReference? = nil
        ref = db.collection(noteCollectionPath).addDocument(data: dict, completion: { (error) in
            if let error = error {
                LoggingUtility.debug("Error adding document \(error)")
            } else {
                LoggingUtility.debug("Document added with ID: \(ref!.documentID)")
            }
        })
    }
    
    
    func readNotes(completion: @escaping ([Note.Dto]?) -> Void) {
        db.collection(noteCollectionPath).getDocuments { (querySnapshot, error) in
            if let error = error {
                LoggingUtility.debug("Error getting documents: \(error)")
                completion(nil)
                return
            }
            
            guard querySnapshot != nil else {
                completion(nil)
                return
            }
            
            var notes = [Note.Dto]()
            for document in querySnapshot!.documents {
                LoggingUtility.debug("\(document.documentID) => \(document.data())")
          
                if let note = try? self.convertToNote(from: document.data()) {
                    LoggingUtility.debug("Note added, \(note)")
                    notes.append(note)
                }
            }
            if notes.isEmpty {
                completion(nil)
            } else {
                completion(notes)
            }
            
        }
    }
    
    // MARK: - Helper methods
    func convertToNote(from dictionary: [String: Any]) throws -> Note.Dto  {
        guard let text = dictionary["text"] as? String,
            let username = dictionary["username"] as? String,
            let latitude = dictionary["latitude"] as? Double,
            let longitude = dictionary["longitude"] as? Double,
            let dateTime = dictionary["datetime"] as? Double
        else {
                throw NoteSyncError.dictionaryToNoteFailed
        }
        
        return Note.Dto(text: text, username: username, latitude: latitude, longitude: longitude, datetime: dateTime)
    }
}

enum NoteSyncError: Error {
    case jsonToDictionaryFailed
    case dictionaryToNoteFailed
}


extension Encodable {
    func asDictionary() throws -> [String: Any] {
        let data = try JSONEncoder().encode(self)
        guard let dictionary = try JSONSerialization.jsonObject(with: data, options: .allowFragments) as? [String: Any] else {
            throw NoteSyncError.jsonToDictionaryFailed
        }
        return dictionary
    }
}
